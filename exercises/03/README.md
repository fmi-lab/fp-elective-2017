Упражнение 3
============

Задачи
------

1. Да се дефинира функция `fibonacci(n)`, която намира `n`-тото число на
Фибоначи. Реализирайте я чрез рекурсивен процес. Реализирайте я чрез итеративен
процес.

2. Дефинираме функция `f` по следните правила:
```
f(n) = n, ако n < 3 и
f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3), ако n ≥ 3
```
Напишете функция, пресмятаща `f` чрез рекурсивен процес. Напишете функция,
пресмятаща `f` чрез итеративен процес.

3. Триъгълникът на Паскал представлява следната фигура от числа:

```
    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1
   ...
```

Числата, намиращи се по страните на триъгълника, са единици. Всяко число,
намиращо се вътре в триъгълника, е сумата на двете числа непосредствено над
него. Напишете функция `binomial-coefficient(row, index)`, пресмятаща елемента
от триъгълника на Паскал, намиращ се на ред `row` и позиция в реда `index`.
Броенето на редовете и позициите започва от 1.

4. В дефинициите на `sum`, `product` и `accumulate` от слайдовете при всяко
рекурсивно извикване на съответната функция към аргумента `a` се прибавя 1.
Напишете по-общ вариант на функциите `sum`, `product` и `accumulate`, като
добавите нов параметър към съответната функция, който да пресмята следващата
стойност на `a`. Пример:
```scheme
(define (identity x) x)
(define (2+ x) (+ x 2))

(sum identity 1 2+ 5) ; 9
(product identity 1 2+ 5) ; 15
(accumulate + 0 identity 1 2+ 5) ; 9
(accumulate * 1 identity 1 2+ 5) ; 15
```
Дефинирайте `accumulate` чрез итерация.

5. Напишете функция `count(predicate, a, b)`, която връща броя на елементите
в интервала `[a, b]`, за които предикатът `predicate` е истина. Ако не сте я
имплементирали чрез `accumulate`, имплементирайте я чрез `accumulate`.

6. Напишете функция, която преброява палиндромите в даден интервал.

7. Напишете предикат `exists?(predicate, a, b)`, който проверява дали съществува
цяло число в интервала `[a, b]`, за което предикатът `predicate` е истина.

8. Напишете предикат `for-all?(predicate, a, b)`, който проверява дали за всяко
цяло число в интервала `[a, b]` предикатът `predicate` е истина.

9. Напишете функция `double`, която приема функция на един аргумент и връща
функция, която прилага подадената функция два пъти. Например, ако имаме
функцията `inc`, която добавя 1 към своя аргумент (`(define (inc x) (+ x 1)`),
то `(double inc)` е функция, която добавя 2 към своя аргумент.

10. Нека `f` и `g` са функции на един аргумент. Композицията `f` ∘ `g` е
функцията x ↦ f(g(x)). Напишете функция `compose(f, g)`, която връща
композицията `f` ∘ `g`. Пример:
```scheme
(define (inc x) (+ x 1))
(define (square x) (* x x))

((compose square inc) 6) ; 49
```

11. Нека `f` е функция на един аргумент и `n` е цяло неотрицателно число.
Дефинираме `n`-тото прилагане на функцията `f` да бъде функцията, дефинирана
по следния начин:

   f<sup>0</sup>(x) = x

   f<sup>n</sup>(x) = f(f<sup>n-1</sup>(x))

Напишете функция `repeated(f, n)`, която връща `n`-тото прилагане на `f`.
Пример:
```scheme
(define (square x) (* x x))

((repeated square 2) 5) ; 625
```

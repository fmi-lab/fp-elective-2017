Упражнение 12
=============

Ще упражним:
- рекурсия
- pattern matching на списъци и кортежи (tuples) `(a, b):xs`
- lambda `\x -> x + 1`
- range `[1,3...]`
- list comprehension `[x**2 | x <- [1..10]]`

Декларирайте типа на всяка функция, която дефинирате.

Списъци в Haskell
-----------------

1. Да се дефинира функция `elem(x, l)`, която
проверява дали елемента `x` присъства в списъка `l`.

2. Да се дефинира функция `reverse(l)`, която обръща списъка `l`.

3. Да се дефинира функция `map(f, l)`, която
прилага функцията `f` върху всеки елемент от списъка `l`.

4. Да се дефинира функция `filter(p, l)`, която
връща списък с всички елементи на `l`, които
удовлетворяват предиката `p`.

5. Да се дефинира функция `foldr(op, nullValue, l)`, която
редуцира (акумулира) елементите на списъка `l` чрез бинарната функция `op`
до една стойност, където `nullValue` е началната стойност на акумулатора.

6. Да се дефинира функция `sort(l)`, която сортира списъка `l`.
Използвайте Quick Sort или друг любим алгоритъм за сортиране.

Матрици
-------

7. Да се дефинира функция `column(m, i)`, която
намира `i`-тата по ред колона, броейки от нула, в матрицата `m`.

8. Да се дефинира функция `transpose(m)`, която
връща транспонираната матрица на `m`.

9. Да се дефинира функция `diagonal(m)`, която
връща главния диагонал на матрицата `m`.

10. Да се дефинира функция `diagonal2(m)`, която
връща втория диагонал на матрицата `m`.

11. Да се дефинира функция `foldm(op, nullValue, m)`, която
редуцира (акумулира) елементите на матрицата `m` чрез бинарната функция `op`
до една стойност, където `nullValue` е началната стойност на акумулатора.

Множества
---------

12. Да се дефинира функция `intersection(a, b)`, която
намира сечението на списъците `a` и `b`.

13. Да се дефинира функция `difference(a, b)`, която
намира разликата на двете множества (списъци) `a` и `b`, като
премахва срещанията на всички елементи на `b` от `a`.

14. Да се дефинира функция `product(a, b)`, която
намира декартовото произведение на двата списъка `a` и `b`
и връща списък от наредени двойки.

    Например, `product [1, 2, 3] [4, 5]` връща
    `[(1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)]`

15. Да се дефинира функция `triplets(n)`, която
връща списък от всички Питагорови тройки със сума по-малка от `n`.

    Например, `triplets 30` връща `[(3, 4, 5), (5, 12, 13), (6, 8, 10)]`

Асоциативни списъци
-------------------

16. Да се дефинира функция `zip(a, b)`, която
обединява поелементно списъците `a` и `b` в списък от наредени двойки.

    Например, `zip [1, 2, 3, 4, 5] ['a', 'b', 'c', 'd']` връща
    `[(1, 'а'), (2, 'b'), (3, 'c'), (4, 'd')]`.

17. Да се дефинира функция `histogram(l)`, която
връща хистограма на срещанията на всички елементи в `l`
под формата на списък от наредени двойки (кортежи).

    Например, `histogram [8, 7, 1, 7, 8, 2, 2, 8, 2, 7, 8, 1]`
    връща асоциативния списък `[(8, 4), (7, 3), (1, 2), (2, 3)]`.

18. Да се дефинира функция `runLengthEncode(l)`, която
кодира списъка `l` в асоциативен списък - списък от наредени двойки
`(<ключ>, <стойност>)`, където `<ключ>`-ът e пореден елемент от списъка `l`, а
`<стойност>`-та е колко пъти се повтаря елемента последователно.

    Например, `runLengthEncode [8, 7, 7, 2, 2, 2, 2, 3, 3, 2]`
    връща асоциативния списък `[(8, 1), (7, 2), (2, 4), (3, 2), (2, 1)]`.
